(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{371:function(n,r,o){"use strict";o.r(r);var _=o(17),e=Object(_.a)({},(function(){var n=this,r=n._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#规范"}},[n._v("#")]),n._v(" 规范")]),n._v(" "),r("h2",{attrs:{id:"数据库设计规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据库设计规范"}},[n._v("#")]),n._v(" 数据库设计规范")]),n._v(" "),r("ul",[r("li",[n._v("数据库不应该创建过多的表\n在wiretiger引擎中，每个集合都需要创建多个文件夹来保存元数据、数据及索引，磁盘上过多的小文件会导致性能下降。"),r("br"),n._v("\n建议单个数据库的表个数控制在100个以内，整个数据库实例的表数量控制在2000个以内。")]),n._v(" "),r("li",[n._v("数据库最好以db开头，不能包含除_以外的特殊字符，所有字母全部小写，数据库名不超过64个字符。")]),n._v(" "),r("li",[n._v("集合名最好以t_开头，不能包含除_以外的特殊字符，集合名不超过120个字符。")])]),n._v(" "),r("h2",{attrs:{id:"索引规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#索引规范"}},[n._v("#")]),n._v(" 索引规范")]),n._v(" "),r("ul",[r("li",[n._v("创建索引时要带上background参数，特别是生产环境"),r("br"),n._v("\nMongoDB 4.2及之前版本，createIndex()命令默认是foreground模式，这种模式下创建索引会阻塞数据库的所有操作，会造成业务中。示例： db.users.createIndex({user_id:1}, {unique:true, background:true})")]),n._v(" "),r("li",[n._v("排序字段需要创建索引，避免业务大量在内存中排序造成数据库OOM(Out Of Memory)\n"),r("ul",[r("li",[n._v('MongoDB 4.2及之前的版本，一条查询默认只允许使用32MB内存进行排序，如果超出会提示Sort operation used more than the maximum 33554432 bytes of RAM错误，通过执行db.adminCommand({setParameter : 1,"internalQueryExecMaxBlockingSortBytes" : 104857600})调整内存。')]),n._v(" "),r("li",[n._v("生产环境禁止调整，这样会增大数据库OOM的概率。建索引时就应该考滤加入排序字段。")]),n._v(" "),r("li",[n._v("MongoDB 4.4版本虽然提供了磁盘排序的选项来避免排序消耗大量内存，但建议最好使用索引排序。")])])]),n._v(" "),r("li",[n._v("一个表不宜创建过多的索引\nMongoDB插入每条数据的时候同时需要写索引。索引越多，写入数据时就要花费更多的代价。单个表索引建议不超过10个。")]),n._v(" "),r("li",[n._v("最好定期清理无用的索引"),r("br"),n._v("\n索引在写操作时会带来额外的资源消耗，所以需要尽量精简索引。"),r("br"),n._v("\nMongoDB 4.4版本之后，可使用hidden index先隐藏掉无用的索引，隐藏后业务确认正常后再删除索引。")]),n._v(" "),r("li",[n._v("按照最左匹配原则，如果单字段索引已经被复合索引包含，应该删除，因为额外的索引会造成写操作时的性能浪费。")]),n._v(" "),r("li",[n._v("尽量避免$ne/$nin等操作，和其他数据库(如MySQL)一样，不等于及not in类的操作无法有效利用索引，应该避免使用。")]),n._v(" "),r("li",[n._v("考滤使用区分度大的字段建立索引"),r("br"),n._v("\n如果索引字段区分度较小，查询扫描的行数依然会比较多，查询效率较低，对数据库负载影响较大。")])]),n._v(" "),r("h2",{attrs:{id:"数据库操作规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据库操作规范"}},[n._v("#")]),n._v(" 数据库操作规范")]),n._v(" "),r("h3",{attrs:{id:"禁止类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#禁止类"}},[n._v("#")]),n._v(" 禁止类")]),n._v(" "),r("ul",[r("li",[n._v("操作命令应该使用explain()确认执行计划"),r("br"),n._v("\n上线执行操作命令前需要用explain()确认执行计划是否符合预期，否则上线可能会引起故障。")]),n._v(" "),r("li",[n._v("生产环境禁止关闭鉴权"),r("br"),n._v("\n关闭鉴权会将数据库暴露给所有人，特别是数据库服务器开通了外网。")]),n._v(" "),r("li",[n._v("admin,local库不能存储业务数据"),r("br"),n._v("\nadmin库读写时会加db锁，影响性能;local库只会保存到本地，不会复制到从节点，如果发生主人切换会丢失数据。")]),n._v(" "),r("li",[n._v("禁止执行db.dropDatabase()命令后再创建同名的db\n"),r("ul",[r("li",[n._v("MongoDB 4.0及之前的版本，官方文档要求删除db并创建同名db后，业务读写数据前需要在所有mongos节点上执行重启或flushRouterConfig命令。")]),n._v(" "),r("li",[n._v("MongoDB 4.2及之后的版本，需要对所有的mongos和mongod节点重启或执行flushRouterConfig命令。"),r("br"),n._v("\n所以禁止在业务代码中直接执行db.dropDatabase()命令后再创建同名的db。")])])]),n._v(" "),r("li",[n._v("高并发高性能场景，禁止过度使用in和or"),r("br"),n._v("\nin 或者or 条件语句在数据库底层需要转换成多次查询，过多的in和or操作在高并发高性能场景，会严重影响请求的响应时延及数据库负载。")]),n._v(" "),r("li",[n._v("高并发高性能场景，禁止将复杂的运算操作交给数据库进行"),r("br"),n._v("\nMongoDB 提供了强大的计算能力（如 MapReduce 等），这些特性对开发人员非常友好，极大减轻了业务逻辑。但是这些运算不可避免是需要资源的，如果将复杂运算下沉到数据库层，高并发场景势必会给数据库造成极大的负担，数据库一旦故障会造成整个系统雪崩。"),r("br"),n._v("\n建议在高并发高性能的场景下，数据库操作保持简单，复杂的运算交给服务器并适当在数据库前端增加缓存。")]),n._v(" "),r("li",[n._v("线上业务禁止直接进行批量数据 remove"),r("br"),n._v("\nremove 命令到数据库后会先查询符合删除条件记录的_id，之后一条条按照_id 进行删除，并记录到 oplog 中（删除每条记录都会写一条 oplog）。"),r("br"),n._v("\n当满足 remove 条件的数据较多时对数据库压力较大，且极容易引起主从延迟突然增大。"),r("br"),n._v("\n线上业务建议直接用 drop 集合或用脚本一条条删除并控制删除速度。或尽量使用 ttl 索引。")]),n._v(" "),r("li",[n._v("业务禁止自定义 _id 字段"),r("br"),n._v("\n_id 是 MongoDB 内部的默认主键，默认这是一个自增的序列。如果自定义_id 并且业务无法保证_id 递增，每次插入数据后，_id 索引不可避免需要对 B 树索引进行调整，这将对数据库带来额外的负担。")]),n._v(" "),r("li",[n._v("副本集直连 mongod 节点的场景，使用禁止只在连接串中配置单个 IP；分片集群集群禁止只连接单个 mongos 地址（除非 mongos 和应用服务器部署在一起）"),r("br"),n._v("\n线上业务如果只连接副本集主节点，一旦数据库发生 HA 会造成写入中断；如果只连接单个 mongos，这个 mongos 故障后会造成业务中断。")]),n._v(" "),r("li",[n._v("线上业务禁止设置 Write Concern j:false"),r("br"),n._v("\nWrite Concern 默认一般为 j:true，表示服务端会写入 journal log 完成后再向 client 端返回。一般请勿设置 j:false，否则进程突然故障重启后，可能会造成数据丢失。")]),n._v(" "),r("li",[n._v("update 语句中禁止不带条件的更新"),r("br"),n._v("\n业务代码要确保query参数不能传{},否则会造成全表数据更新。推荐保持 multi 为默认值（false）。")]),n._v(" "),r("li",[n._v("禁止更新数组内部分元素时，将数组全部拿出来更新后再写回去"),r("br"),n._v("\n推荐使用"),r("a",{attrs:{href:"https://docs.mongodb.com/manual/reference/operator/update/positional-filtered/#std-label-positional-update-arrayFilters",target:"_blank",rel:"noopener noreferrer"}},[n._v("arrayFileters"),r("OutboundLink")],1),n._v("仅对需要的元素进行修改。")])]),n._v(" "),r("h3",{attrs:{id:"建议类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#建议类"}},[n._v("#")]),n._v(" 建议类")]),n._v(" "),r("ul",[r("li",[n._v("建议局部读写而不是全读全写"),r("br"),n._v("\n查询语句中应尽量使用 $projection 运算符投影出需要的字段；在 update 命令中如果只是修改某个字段，建议使用 $set，请勿将文档全部读出来修改后再全量写进去。")]),n._v(" "),r("li",[n._v("线上环境慎重使用 db.collection.renameCollection() 命令"),r("br"),n._v("\nrenameCollection() 在4.0及之前的版本会阻塞 db 的所有操作；在4.2及其之后版本会阻塞当前表及目标表的操作。而且 renameCollection() 执行期间会造成游标失效、changeStream 失效及带 --oplog 命令的 mongodump 失败等问题。线上环境禁止高峰期直接操作。")]),n._v(" "),r("li",[n._v("建议核心业务配置 WriteConcern 为 {w: “majority”} 参数"),r("br"),n._v("\n默认情况下，一般驱动的 WriteConcern 配置为 {w:1}，即在主节点写入完成后认为请求成功。如果机器突然发生故障并且写入的数据还未复制到从节点，这样的配置会导致数据丢失。"),r("br"),n._v("\n因此对于线上的核心业务，建议配置 {w: “majority”}，这样的配置会等数据同步大多数节点后再返回客户端。当然可靠性和性能不能兼顾，选择了 {w: “majority”} 配置后请求的延迟也会相应的增加。")])]),n._v(" "),r("h3",{attrs:{id:"不建议类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#不建议类"}},[n._v("#")]),n._v(" 不建议类")]),n._v(" "),r("ul",[r("li",[n._v("除非必要，不要在高性能场景大量使用多文档事务"),r("br"),n._v("\nMongoDB 4.0 及之后的版本，MongoDB 提供了多文档事务。但是多文档事务只是 MongoDB 数据库能力的补充，在高并发高性能场景下，大规模使用多文档事务需要进行充分的压测。"),r("br"),n._v("\n一般来说，多文档事务提交前需要在内存中保留快照，这可能消耗大量的 cache 从而导致性能下降。")]),n._v(" "),r("li",[n._v("不建议使用短连接"),r("br"),n._v("\nMongoDB 的认证逻辑是一个比较复杂的运算过程，而且默认 MongoDB 会为每个连接创建一个线程。大量短连接会对数据库产生较大的负担，特别是没有 mongos 的副本集集群。建议使用长连接，详细参考 mongodb url 中 Connection Pool 参数。")])]),n._v(" "),r("h2",{attrs:{id:"分片集群设计规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分片集群设计规范"}},[n._v("#")]),n._v(" 分片集群设计规范")]),n._v(" "),r("ul",[r("li",[n._v("如果使用 _id 字段作为片键，禁止使用范围分片"),r("br"),n._v("\nid 默认是一个递增的序列，随着数据量的增加会一直增大。如果_id 作为片键并使用范围分片，集群随着数据的插入不断的进行 balance。")]),n._v(" "),r("li",[n._v("分片集群禁止直连 mongod 节点写数据"),r("br"),n._v("\n分片集群应该通过 mongos 写数据，直接通过 mongod 写入的数据无路由信息，会导致访问不到。")]),n._v(" "),r("li",[n._v("线上环境禁止长时间关闭 balancer 和 autoSplit 配置"),r("br"),n._v("\n关闭 balance 会导致片之间数据不均衡，关闭 autoSplit 可能会产生 jumbo chunk。")]),n._v(" "),r("li",[n._v("分片表尽量避免不带片键的查询"),r("br"),n._v("\n分片表不带片键进行查询，需要扫描所有分片后在mongos聚合结果，比较消耗性能。")]),n._v(" "),r("li",[n._v("线上环境务必设置balancer窗口，避免balance对业务造成影响"),r("br"),n._v("\nbalance过程会明显对数据库造成较大的压力，应该设置在业务低峰期进行。")]),n._v(" "),r("li",[n._v("应该使用区分度较大的字段作为片键，最理想的情况是使用唯一主键作为片键"),r("br"),n._v("\n比如用户表里有性别和姓名这两个字段，一般情况使用性别作为片键的区分度比姓名作为片键的区分度低，因为理论上性别相同的数据会有一半。")]),n._v(" "),r("li",[n._v("如果使用hash分片，建议进行预分配，特别是表比较大且经常需要大量插入数据"),r("br"),n._v("\nshardCollection()命令默认每个分片只会创建2个chunk,随着数据越来越大，MongoDB需要不断地balance和splitChunk,频繁地数据块拆分会给数据库带来较大压力。")]),n._v(" "),r("li",[n._v("没有按片键顺序扫描的强需求，不建议使用range分片，推荐hash分片"),r("br"),n._v("\nrange分片容易引起不均衡和数据热点，而且因为无法预分片所以随着数据的写入balance不可避免，因此不建议使用，除非有特殊的近片键范围查询需求。")]),n._v(" "),r("li",[n._v("分片集群中不建议使用非分片表"),r("br"),n._v("\nMongoDB的分片集群如果未执行shardCollection命令，默认数据只存储在主分片上。大量未分片的表会造成分片间的数据量不平衡。集群长时间运行下去，可能会造成某片数据量特别多，运维在这种情况下不得不使用movePrimary手动进行数据拆迁，从而增加运维复杂度。")])]),n._v(" "),r("Vssue",{attrs:{title:n.$title,options:{locale:"zh"}}})],1)}),[],!1,null,null,null);r.default=e.exports}}]);