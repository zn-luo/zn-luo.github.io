(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{421:function(t,s,_){"use strict";_.r(s);var o=_(17),a=Object(o.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"缓解ddos攻击的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓解ddos攻击的方法"}},[t._v("#")]),t._v(" 缓解DDoS攻击的方法")]),t._v(" "),s("p",[t._v("DDoS: 分布式拒绝服务攻击(Distributed Denial of Service)"),s("br"),t._v("\nDDos的前身是Dos(Denial of Service)，即拒绝服务攻击：指利用大量的合理请求，来占用过多的目标资源，从而使目标服务无法响应正常的请求。"),s("br"),t._v("\nDDoS则是在DoS的基础上采用分布式架构，利用多台主机同时攻击目标主机，从而使即使部署了网络防御设备的目标服务在面对大量网络请求时也无法应对。")]),t._v(" "),s("h2",{attrs:{id:"ddos有以下几种类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ddos有以下几种类型"}},[t._v("#")]),t._v(" DDoS有以下几种类型")]),t._v(" "),s("ul",[s("li",[t._v("消耗带宽。服务器、路由器交换机等网络设备的带宽都是有固定上限的。带宽耗尽后就会发生网络拥堵，从而无法传输其他正常的网络报文。")]),t._v(" "),s("li",[t._v("消耗操作系统资源。网络服务的正常运行需要消耗系统资源，服务器上的CPU、内存等物理资源和连接表等软件资源也都是有限的，一旦资源耗尽，系统就不能处理正常的网络连接。")]),t._v(" "),s("li",[t._v("消耗应用程序的运行资源。应用程序的运行，通常还需要与其他的资源或系统交互。如果应用程序一直忙于处理无效请求，也会导致正常请求的处理变慢，甚至无法响应。")])]),t._v(" "),s("h2",{attrs:{id:"缓解方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓解方法"}},[t._v("#")]),t._v(" 缓解方法")]),t._v(" "),s("h3",{attrs:{id:"缓解syn-flood攻击"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓解syn-flood攻击"}},[t._v("#")]),t._v(" 缓解SYN Flood攻击")]),t._v(" "),s("p",[t._v("编辑/etc/sysctl.conf文件，调整如下内核参数，保存后执行sysctl -p")]),t._v(" "),s("ul",[s("li",[t._v("net.ipv4.tcp_max_syn_backlog：此参数可以调大半连接的数量，即SYN_RCVD状态的数量")]),t._v(" "),s("li",[t._v("net.ipv4.tcp_synack_retries：连接每个SYN_RECV时，如果失败的话，内核会自动重试，并且默认的重试次数是5次。可以将此参数调为1。")]),t._v(" "),s("li",[t._v("net.ipv4.tcp_syncookies: 设置此参数为1开启此功能\n"),s("ul",[s("li",[t._v("SYN Cookies 基于连接信息（包括源地址、源端口、目的地址、目的端口等）以及一个加密种子（如系统启动时间），计算出一个哈希值（SHA1），这个哈希值称为 cookie。")]),t._v(" "),s("li",[t._v("cookie会被用作SYN+ACK响应包的序列号返回客户端，，并释放连接状态。当客户端发送完三次握手的最后一次 ACK后，服务器就会再次计算这个哈希值，确认是上次返回的SYN+ACK响应包，才会进入 TCP 的连接状态。")]),t._v(" "),s("li",[t._v("开启SYN Cookies后，就不需要维护半连接状态了，进而也就没有了半连接数的限制。net.ipv4.tcp_max_syn_backlog 也无效了。")]),t._v(" "),s("li",[t._v("由于cookie占用序列号空间，导致此时所有TCP可选功能失效，如扩充窗口、时间戳等。")])])]),t._v(" "),s("li",[t._v("net.ipv4.tcp_abort_on_overflow: 设置当超出处理能力时，对新来的SYN请求直接回RST，丢弃连接")]),t._v(" "),s("li",[t._v("net.core.netdev_max_backlog: 此参数可设置接收自网卡、但未被内核协议栈处理的报文队列长度")])]),t._v(" "),s("h3",{attrs:{id:"基于-xdp-或者-dpdk-构建-ddos-方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于-xdp-或者-dpdk-构建-ddos-方案"}},[t._v("#")]),t._v(" 基于 XDP 或者 DPDK，构建 DDoS 方案")]),t._v(" "),s("p",[t._v("Linux 内核中冗长的协议栈，在 PPS 很大时，就是一个巨大的负担。可以考滤基于 XDP 或者 DPDK，构建 DDoS 方案，在内核网络协议栈前，或者跳过内核协议栈，来识别并丢弃 DDoS 报文，避免DDoS 对系统其他资源的消耗。")]),t._v(" "),s("h3",{attrs:{id:"针对流量型的-ddos"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#针对流量型的-ddos"}},[t._v("#")]),t._v(" 针对流量型的 DDoS")]),t._v(" "),s("p",[t._v("对于流量型的 DDoS来说，当服务器的带宽被耗尽后，在服务器内部处理就无能为力了。这时，只能在服务器外部的网络设备中，设法识别并阻断流量(前提是当前网络设备要能扛住流量攻击)。比如，购置专业入侵检测和防御设备，配置流量清洗设备阻断恶意流量等。")]),t._v(" "),s("h3",{attrs:{id:"应用程序攻击的慢速-ddos"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用程序攻击的慢速-ddos"}},[t._v("#")]),t._v(" 应用程序攻击的慢速 DDoS")]),t._v(" "),s("p",[t._v("很多针对应用程序的攻击，都会伪装成正常用户来请求资源。这种情况下，请求流量可能本身并不大，但响应流量却可能很大，并且应用程序内部也很可能要耗费大量资源处理。")]),t._v(" "),s("p",[t._v("这时需要应用程序考滤识别，并尽早拒绝掉这些恶意流量，比如合理利用缓存、增加WAF(Web Application Firewall)、使用CDN等。")])])}),[],!1,null,null,null);s.default=a.exports}}]);